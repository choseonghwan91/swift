### 데이터 타입
서로 다른 타입끼리의 데이터 교환은 꼭 `타입 캐스팅`을 거쳐야 한다.

# 타입 별칭
스위프트에서 기본으로 제공하는 데이터 타입이든, 사용자가 임의로 만든 데이터 타입이든 별칭으로 지정이 가능

```swift
typealias IntType = Int
typealias DoubleType = Double

let integer : IntType = 5
let decimal : DoubleType = 3.4

var test : Int = 4
test = integer // no error (같은 Int 타입으로 인식해서 할당 가능)
```

# 튜플
- 튜플은 여러개의 값의 묶음이라고 할 수 있다
- 튜플은 인덱스를 이용해서 값 사용 가능
- 튜플 요소마다 이름을 붙여 줄 수 있음
- 요소 이름 또는 인덱스로 값을 할당 할 수 있음
- 요소 이름을 붙여줘도 인덱스로 접근 가능
- 튜플 별칭 지정 가능
```swift
var person: (String, Int, Double) = ("name", 20, 181.3)
// 튜플에 지정된 데이터의 타입은, 타입들의 묶음을 만들어서 지정 가능

print("이름: \(person.0), 나이: \(person.1), 신장: \(person.2)")
// 이름: name, 나이: 20, 신장: 181.3

var chosh: (name: String, weight: Int, height: Double) = ("seonghwan", 84, 181.3)
print("이름: \(chosh.name), 무게: \(chosh.weight), 신장: \(chosh.height)")
// 이름: seonghwan, 무게: 84, 신장: 181.3

chosh.name = "choseonghwan"
chosh.1 = 86

typealias ChoshValueType = (name: String, weight: Int, height: Int)
let chosh : ChoshValueType = ("choseonghwan", 86, 181.3)
print("이름: \(chosh.name), 무게: \(chosh.weight), 신장: \(chosh.height)")
```


# 컬렉션형
컬렉션 타입에는 배열(Array), 딕셔너리(Dictionary), 세트(Set)등이 있습니다.
### 배열
- Array 라는 키워드와 타입 이름의 조합으로 사용
- 대괄호로 값을 묶어 Array 타입을 표현 가능
- 빈 배열은 이니셜라이저 or 리터럴 문법으로 생성 가능(isEmpty로 비어있는 배열인지 확인 가능)
- 배열의 요소가 몇개 인지 알고 싶다면 count 사용 가능
- 배열은 인덱스를 통해서 값에 접근 가능
- 맨 처음 요소(first)와 맨 마지막 요소(last)를 가져올 수 있음
- `index(of:)`를 사용하여 해당 요소의 인덱스를 알아낼 수 있음
- 맨 뒤에 요소를 추가하고 싶으면 `append(_:)` 메서드를 사용
- 중간에 요소를 삽입 하고 싶다면 `insert(_:at:)` 메서드를 사용
- 요소를 삭제하고 싶다면 `remove(_:at:)` 메서드를 사용(삭제 후 반환)
- 범위연산자(`...`)로 배열의 일부를 가져올 수 있음
- 범위에 맞게 요소를 바꾸는것도 가능
```swift
var language: Array<String> = ["swift", "javascript", "python", "swift"]
// or
var language: [String] = ["swift", "javascript", "python", "swift"]

var emptyArr: [Any] = [Any]() // 이니셜라이저
// or
var emptyArr: [Any] = Array<Any>()

print(emptyArr.isEmpty) // true

print(language.count) // 4

print(language[1]) // javascript

print(language.first) // swift
print(language.last) // swift

print(language.index(of: "python")) // 2

language.append("c")
print(language) // ["swift", "javascript", "python", "swift", "c"]

language.append(contentsOf: ["java", "c++"])
print(language) // ["swift", "javascript", "python", "swift", "c", "java", "c++"]

language.insert("go", at: 3)
print(language) // ["swift", "javascript", "python", "go", "swift", "c", "java", "c++"]

let firstItem: String = language.removeFirst()
print(firstItem) // swift
print(language) // ["javascript", "python", "go", "swift", "c", "java", "c++"]
let lastItem: String = language.removeLast()
print(lastItem) // c++
print(language) // ["javascript", "python", "go", "swift", "c", "java"]
let indexTwoItem: String = language.remove(at: 2)
print(indexTwoItem) // go
print(language) // ["javascript", "python", "swift", "c", "java"]

print(language[1 ... 3]) // ["python", "swift", "c"]
language[1 ... 3] = ["go", "c++", "dart"]
print(language) // ["javascript", "go", "c++", "dart", "java"]
```

# 딕셔너리
요소들이 순서 없이 키와 값의 쌍으로 구성되는 컬렉션 타입
키는 유일한 식별자로 중복된 값을 가질 수 없음

- 딕셔너리의 타입은 `[키타입:밸류타입]` or `Dictionary<키타입,밸류타입>` 으로 지정 가능
- 타입을 명시 해주었다면 `[:]`로 딕셔너리를 생성할 수 있음
- 초기값을 주어 생성 가능

```swift
typealias DicType = [String: Int]

var dicOne: Dictionary<String, Int> = Dictionary<String, Int>()
var dicTwo: [String: Int] = [String: Int]()
var dicThree: DicType = DicType()
// 위에 세가지 방법 모두 동일한 동작 수행

var dicFour: [String: Int] = [:] // 빈 딕셔너리 생성

var dicFive: [String: Int] = ["a": 1, "b": 2, "c": 4]
// 초기값 지정해서 생성 가능
```

- 딕셔너리는 키로 값에 접근 가능
- 딕셔너리에 없는 키에 값 할당하면 새로운 키 생성 가능
- 특정 키의 값을 제거 하려면 `removeValue(forKey:)` 메서드를 사용(제거된후 값 반환해줌)
- 특정 키가 없으면 기본값을 돌려주도록 지정 가능
```swift
print(dicFive["a"]) // 1

dicFive["c"] = 3 // ["a": 1, "b": 2, "c": 3]

dicFive["d"] = 4 // ["a": 1, "b": 2, "c": 3, "d": 4]

let removeItem: Int = dicFive.removeValue(forKey: "d")
print(removeItem) // 4

print(dicFive["d", default: 0]) // 0
```

# 세트 set
순서가 중요하지 않거나 각 요소가 유일한 값이여야 되는 경우에 사용(중복값을 지워줌)
요소로는 해시 가능한 값(swift 기본 데이터 타입)만 가능

- 이니셜라이저나 `[]` 빈 세트 생성 가능
- 배열과 마찬가지로 대괄호를 사용(그렇기 때문에 타입추론으로는 Set을 생성할 수 없음)
- 중복된 값 삭제 됨
- `insert`, `remove` 사용 가능

```swift
var language: Set<String> = Set<String>()
var language: Set<String> = []
// 빈 세트 생성

let test = [1,2,3] 
print(type(of: test)) // Array<Int>, Set가 아님

var setDataList : Set<String> = ["a", "b", "c", "b"]
print(setDataList.count) // 3(중복값 삭제됨)

setDataList.insert("d")
print(setDataList.count) // 4

print(setDataList.remove("c")) // c
```

- 집합 관계를 표현하고자 할 때 유용하게 사용가능
- `intersection` 을 사용하여 교집합인지 확인 가능
- `symmetricDifference` 를 사용하여 여집합의 합 구하기 가능
- `union` 을 사용하여 합집합 구하기 가능
- `subtracting` 을 사용하여 차집합 구하기 가능

```swift
let frontend: Set<String> = ["sh", "pn", "sj"]
let backend: Set<String> = ["wj", "jh", "sj"]

let intersectSet: Set<String> = frontend.intersection(backend) // ["sj"] 교집합
let symmetricDiffSet: Set<String> = frontend.symmetricDifference(backend) // ["sh", "pn", "wj", "jh" ] 여집합의 합 (서로 가지고있지 않은 값)
let unionSet: Set<String> = frontend.union(backend) // ["sh", "pn", "sj", "wj", "jh"] 합집합
let subractSet: Set<String> = frontend.subtracting(backend) // ["sh", "pn"] 차집합
```

- `isDisjoint(with:)` 를 사용하여 서로 배타 적인지 확인 가능
- `isSubset(of:)` 를 사용하여 부분 집합인지 확인 가능
- `isSuperset(of:)` 를 사용하여 전체 집합인지 확인 가능

```swift
let frontend: Set<String> = ["sh", "pn", "sj"]
let backend: Set<String> = ["wj", "jh", "mh"]
let developer: Set<String> = frontend.union(backend)

print(frontend.isDisjoint(with: backend)) // true 배타적인지
print(frontend.isSubset(of: developer)) // true 프론트엔드가 디벨로퍼의 부분 집합인지 확인
print(developer.isSuperset(of: backend)) // true 디벨로퍼가 백엔드의 전체 집합인지 확인
```


# 열거형
- 연관된 항목들을 묶어서 표현할 수 있는 타입
- 정의해준 값 외에는 추가/수정이 불가
- 정해진 값만 열거형 값에 속할 수 있음

스위프트의 열거형은 enum이라는 키워드로 선언

```swift
enum School {
	case primary 
    case elementary 
    case middle
    case high
    case college
    case university
    case graduate
}

// 한줄에 모두 표현 가능
enum School {
	case primary, elementary, middle, high, college, university, graduate
}

열거형은 각 항목의 원시값도 가질 수 있음
원시값을 사용하고 싶다면 rawValue 라는 프로퍼티를 통해 가져올 수 있음
일부만 지정도 가능(지정하지 않은 부분은 키워드 값으로 반환)

```swift
enum School: String {
	case primary = "유치원"
    case elementary = "초등학교"
    case middle = "중학교"
    case high = "고등학교"
    case college = "대학"
    case university = "대학교"
    case graduate
}

let value: School = School.university
let value2: School = Schhol.graduate

print(value) // university
print(value.rawValue) // 대학교
print(value2.rawValue) // graduate

enum Numbers: Int {
	case zero
    case one
    case two
    case ten = 10
}
//타입을 Int로 지정했기 때문에 지정하지 않은 값의 rawValue는 인덱스로 부여 됨
```

#### 연관값
연관값을 가지는 열거형
```swift
enum MainDish {
	case pasta(taste: String)
    case pizza(dough: Stirng, topping: String)
    case chicken(withSauce: Bool)
    case rice
}

var dinner: MainDish = MainDish.pasta(taste: "크림")
dinner = .pizza(dough: "치즈크러스트", topping: "불고기")
dinner = .chicken(withSauce: true)
dinner = .rice 
// 이런식으로 MainDish 안에 있는 값을 지정 해줄 수 있음
```

열거형 안에 열거형
```swift
enum PastaTaste {
	case cream, tomato
}
enum PizzaDough {
	case cheeseCrust, thin, original
}
enum PizzaTopping {
	case pepperoni, cheese, bacon
}

// 특정 메뉴로 한정 지으려면 타입값을 열거형으로 지정 해주면 가능
enum MainDish {
	case pasta(taste: PastaTaste)
    case pizza(dough: PizzaDough, topping: PizzaTopping)
    case chicken(withSauce: Bool)
    case rice
}
```


